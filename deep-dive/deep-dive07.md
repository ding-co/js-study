# Deep Dive 7. 13 ~ 17장 스코프, let, const, 객체, 프로퍼티 등

### _스코프_

- 스코프 (유효 범위)
- JS는 Lexical Scope (함수형 언어 대부분)
  - 실행 위치가 아닌 문맥에 따라 스코프 정해짐
  - 코드가 선언되어 있는 위치가 나의 boundary가 됨
- var, 함수 선언문 => 함수 레벨 스코프
- let, const => 블록 레벨 스코프
- 스코프는 파일의 폴더 개념과 동일
  - 해당 폴더에 중복되는 파일 있을 수 없음
- var는 변수 중복 선언 가능
- 스코프 체인 (실행 컨텍스트 참고)
  - 제일 안에서 밖으로 변수 찾아감
  - 변수는 가능하면 가까운 쪽 내에서 선언하는 것이 좋음
- 렉시컬 환경은 단방향 연결 (안 -> 밖)
  - 밖에서 안으로 접근은 불가
- for 문에 var가 있으면 조심해야 함
  - for 문의 var 변수는 전역 변수임
  - for 문 아직 시작 안되었으므로 var i (반복 변수)는 바깥에 있는 것임
  - 따라서 for 문의 반복 변수는 let 키워드 사용
- 함수를 어디에 정의했는지에 따라 함수의 상위 스코프 결정됨
- C/C++/Java는 실행 시점에 상위 스코프 결정됨

### _전역 변수의 문제점_

- for 문의 var i 도 전역 변수이므로 문제 생김
- 전역 변수는 꼭 필요할 때만 사용하기
- 전역 변수는 오해의 소지가 너무 많음
- 변수 네이밍 (숫자 야구)
  - let gStrikeCnt;
  - var 키워드는 윈도우 객체의 프로퍼티로 들어감
- 전역 변수 검색은 스코프 종점에 있므므로 제일 느림
- 변수는 최대한 사용하는 곳에서 선언 (전역 변수 아닌 경우)
- 전역 변수 억제 방법
  - 즉시 실행 함수 (IIFE); 실행 끝나면 함수 객체 자체를 메모리에 반환 (해제)
  - 네임스페이스 객체
    - 과거에 많이 사용 (ES5)
    - var App = {}
    - App.fn = function () {}
    - App.strikeCnt = 0
    - App.jsx/tsx 가 제일 바깥쪽 global 객체임 (모든 것 총괄)
      - ES5 잔재 (과거)
    - index.jsx가 App.jsx 부름
  - 모듈 패턴
    - 클로저 연관
    - 유용함
  - ES6 모듈 (HTML script embed)
    - 모듈 스코프 (모듈 내에서만 가능)

### _let, const 키워드와 블록 레벨 스코프_

- let, const는 동일 스코프내에 중복 선언 불가
  - 선언 전에 사용 불가
- let 도 호이스팅 됨
  - 위로 올라는 갔지만 (선언은 되었지만)
  - 나중에 선언문 다시 만날 때 초기화됨
  - 그 gap이 TDZ (일시적 사각 지대)
- let은 선언 단계와 초기화 단계 분리됨
- var은 전역 객체에 속함
- const 키워드로 선언한 변수는 선언과 동시에 초기화
  - TDZ 존재 X
  - const의 장점은 메모리 속에서 늘어나고 줄어드는 경우 없음
  - 우선 const로 변수 선언하고 뒤에서 값 변경되면 let으로 변경

### _프로퍼티 어트리뷰트_

- ECMA 명세 정의되어 있음 (JS 런타임 만들기)
- JS 엔진은 프로퍼티를 생성할 때 프로퍼티 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의함
  - 프로퍼티 상태에 대한 메타 데이터 있음
  - enumerable이 true => for in이나 Object.keys()할 떄 에러 안남
    - 값은 안나옴, 그냥 그렇게 해놓음 (number 타입 조심)
  - Object.getOwnPropertyDescriptors (암기하면 좋음)
- getter (get 함수()), setter 함수 (set 함수()) => 변수처럼 사용 가능
- value object; value를 나타내는 object (JSON 객체)
  - 메서드 call X
  - 값으로서의 역할 (데이터 전달 목적)
  - value object의 프로퍼티를 모두 private으로 잡음
    - id 값은 변경 불가 (id는 getter만 있음, setter 있으면 안됨)
    - name 변경하고 싶으면 name에 해당하는 setter만 따로 만듦
    - 직접 name 바꾸는건 오동작 발생 가능, 간접적으로 바꿀 수 있도록 제공
- JS에서 객체 private 변수 만들고 싶으면 IIFE로 클로저 사용해야 함

### _생성자 함수에 의한 객체 생성_

- new Object()
  - JS 런타임이 제공하는 빌트인 객체

#

### [Note]

- 서류; 비전공자들은 왜 개발자가 되고 싶은지 스토리 필요
- 신입은 운7 기3 이므로 쫄면 안됨
- 카카오 채용 관련
  - 1차 코테1 - 1문제
    - 코테에서 1번 문제가 매우 중요
  - 2차 코테2
  - 3차 기술 면접1
  - 4차 기술 면접2
  - 5차 컬쳐핏
- 네이버는 전화 면접도 봄
- 기술 면접 시 모르는 부분은 어디 까지 안다라고 단정적으로 말하기
- 숫자 야구 게임 (코테 연습)
- 문제 다 못 풀면 못 푼 문제들 함수 이름만 선언해놓기
  - 틀만 짜놓기 (세부 로직 구현 다 못해도)
  - 전역 변수 빼고 전역 스코프에 로직 넣지 말고 다 함수로 빼놓기
- window, global, globalThis
- 클래스도 속에서 함수임
- 개념적인 블록
- 실행 컨텍스트
  - 빌트인 객체 (JS 런타임에 이미 만들어져 있는 객체)를 먼저 올림
  - 전역 객체도 있음
    - 전역 객체 안에 var로 선언한 변수 잡힘
  - let, const는 선언적 환경 레코드에 따로 잡힘
    - Record는 해시 테이블 의미
- for in 은 인덱스, for of는 값
