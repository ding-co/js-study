# Deep Dive 5. 10장 객체 리터럴

### _객체 리터럴_

- 리터럴: 값으로 표현되는 것
- 함수, 정규 표현식 등은 객체
- JS에서 객체는 클래스라고 생각하면 됨
- 프로퍼티(멤버 변수), 메서드(멤버 함수)
- public, private 한 메서드
  - public 메서드; 외부에서도 호출 가능
  - private 메서드; 외부에서 호출 불가
- 객체 리터럴; JS 엔진이 평가하고 실행되면 바로 인스턴스 됨
  - new 안해도 상관 없음
  - 대신 클래스로 선언했으면 new 사용해야 함
- 객체 !== JSON
  - JSON은 쌍따옴표 붙여야 함
  - JS object는 key가 숫자로 시작해도 됨
  - key로 예약어 써도 되지만 안쓰는 것 권장
  - key로 하이픈 쓰고 싶으면 따옴표 붙여야 함
    - 아니면 하이픈 대신 언더 스코어 사용
- 똑같은 키 있으면 overwrite 함
  - 속에 해시 테이블로 되어 있어서 그럼
- 메서드
  - ES5에서는 `메서드이름: function()`
  - ES6 이후는 바로 `메서드이름()`로 표현
- 없는 키 부르면 undefined (에러 발생 X)
- 키 이름을 string으로 주고 싶을 때 대괄호 사용해서 안에 string
  - 대괄호 안에 변수도 이용 가능
- 프로퍼티 축약 표현
  - 변수 이름이랑 프로퍼티 키 이름 같을 때 하나만 써도 됨
- 계산된 프로퍼티 이름

#

### [Note]

- null 병합 연산자
- 옵셔널 체이닝 연산자
- 컴파일러; 토크나이징 => 하이픈 만나면 분리하게 됨
- Hash
  - Map 도 해시임
    - put('id', 1)
    - get('id')
    - Map도 키 중복 안됨
  - Set 도 다 내부가 해시임
    - Set도 집합이므로 중복 안됨
- Hash와 Hash table 다른 용어임
  - Hash table; key - value (둘 다 사실 string 임)
    - 주소 값도 string임 (2 or 16진수)
    - 만약 그대로 넣는다 해도 메모리에 object 그대로 넣을 수 없음
      - 따옴표로 감싸야 함 (JSON)
      - JSON.parse( ) 이용하면 JSON 객체로 떨어짐
      - 넣을 때는 JSON.stringify( ) 로 집어 넣음
    - key는 절대 중복되면 안됨 (똑같은 key는 덮어씀)
    - 만약 중복이면 무엇을 줘야 할지 모름
    - key 값을 Hashing 함
      - key들을 순차 탐색하기에는 시간이 너무 오래 걸림
      - 목차(인덱스) 만들어도 시간 많이 걸림
      - key를 해싱 돌림
      - 만약 메모리 용량 딸리면 디스크에 써야 함
      - 용량 한계로 객체 그대로 넣는게 아니라 string으로 넣음 (ex. {x: '{'y':1}'})
      - key를 가지고 hash 함수 돌림 (JS 엔진마다 구현 방식 다름)
        - hash 돌리면 key 에 대한 unique 값 나옴 (번지수 나옴)
        - unique 한 주소 알면 바로 찾아갈 수 있음
        - key 의 순서를 hash 함수를 통해 돌려놓은 것임
        - unique한 결과 값은 알 수 없음 (구현 방식 다 다름)
        - 암호화 알고리즘
          - ex) message digest
          - 10진수 -> 16진수
          - 16진수 -> 64진수
            - 64진수; 알파벳(27) + 소문자(27) + 숫자(10)
          - JS는 32진수 많이 사용
          - 변환시켜서 숫자로 떨구면 주소 나옴
          - 비트 연산 해도 됨
    - 해시 돌려서 나온 결과 값이 메모리 주소로 활용될 수 있지만 <br/>
      만약 안되면 다시 알고리즘 이용해서 범위 내로 표현 필요 <br/>
      ex) 3801 % 100 => 1 + 100 => 101 (노드가 미리 잡아놓은 메모리 주소)
- Redis 같은 메모리 캐시도 다 key/value 쌍임 (해시)
- C는 컴파일할 때 메모리 이미 확보됨
- 노드 실행시키면 런타임에 메모리 충분히 어느정도 미리 확보함
  - heap 메모리 영역 확보시킨 것임
  - 노드 여러개 띄우면 메모리 부족 현상 나올 수 있음
  - 메모리 다 써버리면 null pointer exception이나 stack overflow 나 메모리 full 같은 에러 나옴
